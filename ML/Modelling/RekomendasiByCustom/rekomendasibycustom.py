# -*- coding: utf-8 -*-
"""RekomendasibyCustom.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xb09VK_wckii6nRKhC0ZetHCx7jBiKH2

## **üß© Pemilihan Algoritma untuk Rekomendasi Berdasarkan Filter Custom**

üõ†Ô∏è **Strategi**: Mekanisme ini menerima input berupa filter kustom dari pengguna seperti _Growth_, _Soil_, _Sunlight_, _Watering_, dan _Fertilization_. Input ini bersifat **deskriptif tekstual** sehingga direpresentasikan dalam bentuk **TF-IDF vektor**, mencerminkan hubungan semantik antar tanaman berdasarkan kesamaan deskripsi fitur.

üß† **Keputusan**: Dipilih algoritma **Neural Network (MLP via TensorFlow)** karena:
- Mampu menangani **representasi TF-IDF** berdimensi tinggi tanpa kehilangan fleksibilitas.
- Dapat belajar **pola kompleks** dalam kombinasi fitur yang tak teratur dan sparsity.
- Lebih baik untuk pengembangan sistem dinamis dan dapat ditingkatkan dengan fine-tuning.

üìä **Alternatif seperti** Random Forest tidak optimal pada vektor sparse karena tiap pohon memperlakukan fitur secara terpisah dan bisa menghasilkan struktur berlebihan. KNN tidak cocok karena kesulitan menangani vektor berdimensi tinggi (curse of dimensionality), serta berat saat prediksi (lazy learner).

---

### üìã Tabel Perbandingan Algoritma

| Aspek Evaluasi                  | ‚úÖ MLP (TensorFlow)          | üü° Random Forest               | üî¥ K-Nearest Neighbors (KNN)    |
|----------------------------------|-------------------------------|--------------------------------|----------------------------------|
| Cocok untuk TF-IDF Input        | ‚úîÔ∏è Sangat Baik               | ‚ùå Kurang efisien              | ‚ùå Tidak efisien                |
| Tangani Data Sparsed            | ‚úîÔ∏è Ya                        | ‚ùå Cenderung tidak efisien     | ‚ùå Tidak cocok                  |
| Kompatibel dengan Dimensi Tinggi| ‚úîÔ∏è Didesain untuk itu        | ‚ùå Bisa overfitting            | ‚ùå Sangat terbatas              |
| Multiclass Support              | ‚úîÔ∏è Native Support            | ‚úîÔ∏è Ya, tapi berat              | ‚ö†Ô∏è Kurang scalable             |
| Potensi Pengembangan Model      | ‚úîÔ∏è Bisa ditingkatkan terus   | ‚ö†Ô∏è Terbatas                    | ‚ùå Tidak bisa dilatih ulang    |

---

üìå **Kesimpulan**: Neural Network (MLP via TensorFlow) adalah pilihan paling adaptif dan scalable untuk menangani mekanisme berbasis input tekstual dan vektor sparsity tinggi seperti TF-IDF, terutama dalam sistem rekomendasi dinamis berbasis filter pengguna.

## **1Ô∏è‚É£ Install & Import Library**
"""

!pip install gdown scikit-learn tensorflow --quiet

import pandas as pd
import numpy as np
import gdown
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.utils import to_categorical

"""## **2Ô∏è‚É£ Download & Load Dataset PlansAndFamily**"""

# 2Ô∏è‚É£ Download & Load Dataset PlansAndFamily
url = "https://drive.google.com/uc?id=1nXnJKn-3TCXBW3URPzmRc7WH3cYQQ6Fe"
gdown.download(url, "PlansAndFamily.csv", quiet=False)
df = pd.read_csv("PlansAndFamily.csv")

"""## **3Ô∏è‚É£ Preprocessing Fitur Gabungan**"""

df = df.dropna(subset=["Plant Name"])
filter_cols = ["Growth", "Soil", "Sunlight", "Watering", "Fertilization Type"]
df['combined'] = df[filter_cols].fillna("").agg(' '.join, axis=1)

"""## **4Ô∏è‚É£ Encode Label Target**"""

le = LabelEncoder()
df['label'] = le.fit_transform(df['Plant Name'])

"""## **5Ô∏è‚É£ TF-IDF Vectorization**"""

tfidf = TfidfVectorizer()
X = tfidf.fit_transform(df['combined']).toarray()
y = to_categorical(df['label'])  # TensorFlow expects one-hot encoding

"""## **6Ô∏è‚É£ Train üì¶ TensorFlow Classifier (MLP)**"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = Sequential([
    Input(shape=(X.shape[1],)),
    Dense(128, activation='relu'),
    Dense(64, activation='relu'),
    Dense(y.shape[1], activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.fit(X_train, y_train, epochs=10, batch_size=16, validation_split=0.1, verbose=0)

"""## **7Ô∏è‚É£ Fungsi Prediksi Berdasarkan Filter User**"""

recommendation_history_custom = set()

def recommend_plants_by_filter(user_filters: dict, top_n=3, reset=False):
    global recommendation_history_custom

    if reset:
        recommendation_history_custom = set()

    selected_features = [v for v in user_filters.values() if v.lower() != 'none']
    if not selected_features:
        return ["Tidak ada filter yang dipilih"]

    user_query = ' '.join(selected_features)
    user_vector = tfidf.transform([user_query]).toarray()

    probs = model.predict(user_vector, verbose=0)[0]
    top_indices = probs.argsort()[::-1]  # descending order
    predictions = [(le.inverse_transform([idx])[0], probs[idx]) for idx in top_indices]

    top_plants = []
    for name, _ in predictions:
        if name not in recommendation_history_custom:
            top_plants.append(name)
            recommendation_history_custom.add(name)
        if len(top_plants) == top_n:
            break

    return df[df['Plant Name'].isin(top_plants)][['Plant Name'] + filter_cols].drop_duplicates('Plant Name')

"""## **8Ô∏è‚É£ Contoh Penggunaan**"""

user_filters = {
    "Growth": "none",
    "Soil": "well-drained",
    "Sunlight": "full sunlight",
    "Watering": "Keep soil evenly moist",
    "Fertilization Type": "Organic"
}
recommend_plants_by_filter(user_filters, reset=False)

"""## **9Ô∏è‚É£ Simpan Model & Encoder ke File .h5**"""

# model.save("RekomendasibyCustom_model.h5")

# # Simpan TF-IDF dan LabelEncoder
# import pickle

# with open("tfidf_vectorizer.pkl", "wb") as f:
#     pickle.dump(tfidf, f)

# with open("label_encoder.pkl", "wb") as f:
#     pickle.dump(le, f)